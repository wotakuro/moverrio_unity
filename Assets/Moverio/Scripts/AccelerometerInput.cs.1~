using UnityEngine;
using System.Collections;

public class AccelerometerInput : MonoBehaviour {
    /*---- properties ----*/

    public LineRenderer xRender;
    public LineRenderer yRender;
    public LineRenderer zRender;

    /*---- vars ----*/

    private Vector3[] graphData = new Vector3[256];
    private int index;
    private bool updateFlag;

    // Use this for initialization
	void Start () {
        int length = graphData.Length;
        xRender.SetVertexCount(length);
        yRender.SetVertexCount(length);
        zRender.SetVertexCount(length);
        updateFlag = true;

        Screen.sleepTimeout = SleepTimeout.NeverSleep;
    }
	
	// Update is called once per frame
	void FixedUpdate () {
        if (updateFlag)
        {
            this.UpdateGraph();
        }
	}
    void UpdateGraph()
    {
        Vector3 data = Input.acceleration;
        int length = graphData.Length;

        graphData[index] = data;
        index++;
        index %= length;


        for (int i = 0; i < length; ++i)
        {
            int tmpIdx = (index + i) % length;
            float pos = i * 0.05f - 6.0f;
            float rate = 6.0f;

            xRender.SetPosition(i, new Vector3(pos, graphData[tmpIdx].x * rate, 10));
            yRender.SetPosition(i, new Vector3(pos, graphData[tmpIdx].y * rate, 10));
            zRender.SetPosition(i, new Vector3(pos, graphData[tmpIdx].z * rate, 10));
        }
    }

    bool JudgeInput()
    {
        Vector3 min = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
        Vector3 max = new Vector3(float.MinValue, float.MinValue, float.MinValue);
        for (int i = 0; i < 6; ++i)
        {
            int tmpIdx = (index + graphData.Length - i) % graphData.Length;
            min.x = Mathf.Min(graphData[tmpIdx].x, min.x);
            min.y = Mathf.Min(graphData[tmpIdx].y, min.y);
            min.z = Mathf.Min(graphData[tmpIdx].z, min.z);

            min.x = Mathf.Max(graphData[tmpIdx].x, max.x);
            max.y = Mathf.Max(graphData[tmpIdx].y, max.y);
            max.z = Mathf.Max(graphData[tmpIdx].z, max.z);
        }
        if (min.x < -2.0f && max.x > 2.0f)
        {
            return true;
        }
        if (min.y < -2.0f && max.y > 2.0f)
        {
            return true;
        }
        if (min.z < -2.0f && max.z > 2.0f)
        {
            return true;
        }

        return false;
    }

    void OnGUI() { 
        Rect r = new Rect( 50,50,50,50);
        xRender.enabled = GUI.Toggle(r, xRender.enabled, "x");
        r.x += 70.0f;
        yRender.enabled = GUI.Toggle(r, yRender.enabled, "y");
        r.x += 70.0f;
        zRender.enabled = GUI.Toggle(r, zRender.enabled, "z");
        r.x = 50;
        r.y += 70;
        updateFlag = GUI.Toggle(r, updateFlag, "update");

        r.y += 60;
        if (this.JudgeInput()) {
            GUI.Label(r, "Input!!");
        }
    }
}
